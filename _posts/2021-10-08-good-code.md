---
title: "차근차근 JavaScript"
permalink: /cs/goodcode
tags:
  - [CS]

navigation: true
toc: true
toc_sticky: true

date: 2021-10-08
last_modified_at: 2021-10-08
---

![]()

# 데이터 타입

## Variable
어플리케이션을 실행하게 되면, 어플리케이션마다 쓸 수 있는 메모리가 할당된다.
이 메모리는 텅텅 빈 박스들인데, 어플리케이션마다 그 박스의 갯수가 제한적으로 할당된다.
let name 이라는 키워드로 변수를 정의하면, 한가지의 박스를 가리킬 수 있는 포인터가 생긴다
name이라는 변수가 가리키고 있는 어딘가에 Jeenie라는 값을 저장할 수 있음
추후에 가리키고 있는 곳에 다른값을 넣어 저장할 수 있음 
## Block scope와 Global scope 

### block scope
{  } 이렇게 블럭 안에서 선언된 변수들.
블럭 안에서 선언된 이 name이라는 변수를 밖에서 접근하게 되면 아무값도 나오지않음
- 블럭 밖에서는 접근할 수 없다! 

### global scope
{ } 블럭을 쓰지 않고 파일 안에 바로 정의해서 쓰는 변수들.
- 블럭 밖에서도 접근 가능하고, 블럭 안에서도 접근 가능하다 

=> global 변수는 어플리케이션 실행된 순간부터 끝까지 항상 메모리에 탑재되어 있기 때문에, 최소한으로 쓸 것.
가능하면 class나 함수, if나 for 루프 등 필요한 부분에서만 정의해서 쓰는 것이 좋다. 

## let
let은 es6에 추가됨. mutable data type
* var는 쓰지 말 것!
쓰면 안되는 이유
1. 대부분 프로그래밍 언어에서는 변수를 선언한 후에 값을 할당함
하지만 JS var에서는 선언도 하기전에 값을 할당할 수 있음(미친행동)
이것을 <b>var hoisting</b> 이라고 함
(hoisting이란? 어디에 선언했느냐에 상관없이 제일 위로 끌어올려주는 것을 말함)
2. var는 block scope을 철저하게 무시한다!
block scope 안에서 var로 선언한 변수인데 밖에서 호출이 가능함.
(아무리 깊은 곳에 선언을 한다고 해도 어디에서나 호출할 수가 있어서, 규모가 큰 프로젝트에서 선언하지도 않은 값들이 할당되어서 오기도 함.) 

=> 이러한 위험성 때문에 var 대신 let을 써야함! 

## constants
es6에서 추가됨. immutable data type
값을 한번 할당하면 절대 바뀌지 않음.
기존의 변수를 이용하면, 메모리 어딘가에 할당된 박스를 가리키고 있어서 포인터를 이용해 값을 계속 바꿔나갈 수 있지만
바로 이 constants는 값을 가리키는 포인터가 잠겨있다. 한번 선언과 동시에 할당한 뒤로는 절대 값을 변경할 수 없음
favor immutable data type always
: 웬만하면 한번 할당한 뒤에는 값이 변경되지 않는 그런 데이터타입에 사용해라
이유?
1. 안전성
2. thread safety
어플리케이션이 실행되면 한가지 프로세스가 할당되고 그 프로세스 안에서는 다양한 thread가 동시에 돌아가면서 좀 더 빠르고 효율적으로 동작할 수 있도록 도와준다. 다양한 thread들이 동시에 변수에 접근을 해서 값을 변경할 수 있는데, 동시에 값을  변경한다는 것은 위험하다.
그래서 가능하면 이렇게 값이 변하지 않는 변수를 사용하는 것이 좋다.(앞으로 변경해야할 좋은 이유가 없다면)
코드변경시나 타인이 코드변경시에도 실수를 방지할 수 있다.

바이러스가 mutation을 통해서 계속 유전자의 서열을 바꿔나가듯이,
데이터의 타입에도 변경가능한 mutable과 변경불가능한 immutable이 있다.
## variable types
###primitive type 더이상 작은 단위로 나눠질 수 없는 하나의 아이템
number, boolean, null, undefined, simbol

####number
c언어와 java는 number에 얼마나 큰 데이터를 저장하는지 선언해야하지만 JS는 그럴필요 없음
JS에서는 integer와 decimal number 상관없이 타입은 number

const infinity = 1 / 0;
positive한 value의 값을 0으로 나누면 무한대
const negativeinfinity = -1 / 0;
negative한 value의 값을 0으로 나누면 무한대
const nAn = 'not a number' / 2;
숫자가 아닌 string을 숫자로 나누게 되면 nAn

* const bigInt = 1224456745889554785n;
숫자 끝에 n을 붙이면 bigInt로 인식(아직 지원안되는 브라우저 있음)

#### string
한가지의 글자든 여러개의 글자든 다 string 타입.
다른 string과 붙이는 것도 가능
##### template literals
`hi ${brendan}!` 이렇게 붙여서 쓸 수 있음

#### boolean
##### false
0, null, undefined,NaN, ' '
##### true
any other type

#### null
let nothing = 'null';
명확하게 empty 값을 지정 = null로 값이 할당됨

#### undefined
let x = 'undefined';
let x; 위와 동일
선언은 되었지만 값이 아무것도 들어가지 않음

#### symbol
const symbol1 = Symbol('id');
const symbol2 = Symbol('id');

map이나 다른 자료구조에서 고유한 식별자가 필요하거나, 아니면 동시다발적으로 일어날 수 있는 코드에서 우선순위를 주고싶을 때, 정말 고유한 식별자가 필요할 때 사용
식별자를 string으로 두면 다른 코드에서 동일한 string을 만날때 같은 식별자로 간주함

###object type
싱글 아이템들을 묶어서 한 단위, 한 박스로 관리할 수 있게 해줌
#####first-class function
function도 다른 데이터 타입처럼 변수에 할당이 가능
함수의 parameter(인자)로도 전달이 됨
함수에서 return 타입으로도 function을 리턴 가능