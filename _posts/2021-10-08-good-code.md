---
title: "차근차근 JavaScript"
permalink: /cs/goodcode
tags:
  - [CS]

navigation: true
toc: true
toc_sticky: true

date: 2021-10-08
last_modified_at: 2021-10-08
---

![]()

# 데이터 타입

## Variable
어플리케이션을 실행하게 되면, 어플리케이션마다 쓸 수 있는 메모리가 할당된다.
이 메모리는 텅텅 빈 박스들인데, 어플리케이션마다 그 박스의 갯수가 제한적으로 할당된다.
let name 이라는 키워드로 변수를 정의하면, 한가지의 박스를 가리킬 수 있는 포인터가 생긴다
name이라는 변수가 가리키고 있는 어딘가에 Jeenie라는 값을 저장할 수 있음
추후에 가리키고 있는 곳에 다른값을 넣어 저장할 수 있음 
## Block scope와 Global scope 

### block scope
{  } 이렇게 블럭 안에서 선언된 변수들.
블럭 안에서 선언된 이 name이라는 변수를 밖에서 접근하게 되면 아무값도 나오지않음
- 블럭 밖에서는 접근할 수 없다! 

### global scope
{ } 블럭을 쓰지 않고 파일 안에 바로 정의해서 쓰는 변수들.
- 블럭 밖에서도 접근 가능하고, 블럭 안에서도 접근 가능하다 

=> global 변수는 어플리케이션 실행된 순간부터 끝까지 항상 메모리에 탑재되어 있기 때문에, 최소한으로 쓸 것.
가능하면 class나 함수, if나 for 루프 등 필요한 부분에서만 정의해서 쓰는 것이 좋다. 

## let
let은 es6에 추가됨. mutable data type
* var는 쓰지 말 것!
쓰면 안되는 이유
1. 대부분 프로그래밍 언어에서는 변수를 선언한 후에 값을 할당함
하지만 JS var에서는 선언도 하기전에 값을 할당할 수 있음(미친행동)
이것을 <b>var hoisting</b> 이라고 함
(hoisting이란? 어디에 선언했느냐에 상관없이 제일 위로 끌어올려주는 것을 말함)
2. var는 block scope을 철저하게 무시한다!
block scope 안에서 var로 선언한 변수인데 밖에서 호출이 가능함.
(아무리 깊은 곳에 선언을 한다고 해도 어디에서나 호출할 수가 있어서, 규모가 큰 프로젝트에서 선언하지도 않은 값들이 할당되어서 오기도 함.) 

=> 이러한 위험성 때문에 var 대신 let을 써야함! 

## constants
es6에서 추가됨. immutable data type
값을 한번 할당하면 절대 바뀌지 않음.
기존의 변수를 이용하면, 메모리 어딘가에 할당된 박스를 가리키고 있어서 포인터를 이용해 값을 계속 바꿔나갈 수 있지만
바로 이 constants는 값을 가리키는 포인터가 잠겨있다. 한번 선언과 동시에 할당한 뒤로는 절대 값을 변경할 수 없음
favor immutable data type always
: 웬만하면 한번 할당한 뒤에는 값이 변경되지 않는 그런 데이터타입에 사용해라
이유?
1. 안전성
2. thread safety
어플리케이션이 실행되면 한가지 프로세스가 할당되고 그 프로세스 안에서는 다양한 thread가 동시에 돌아가면서 좀 더 빠르고 효율적으로 동작할 수 있도록 도와준다. 다양한 thread들이 동시에 변수에 접근을 해서 값을 변경할 수 있는데, 동시에 값을  변경한다는 것은 위험하다.
그래서 가능하면 이렇게 값이 변하지 않는 변수를 사용하는 것이 좋다.(앞으로 변경해야할 좋은 이유가 없다면)
코드변경시나 타인이 코드변경시에도 실수를 방지할 수 있다.

바이러스가 mutation을 통해서 계속 유전자의 서열을 바꿔나가듯이,
데이터의 타입에도 변경가능한 mutable과 변경불가능한 immutable이 있다.

Note !
Immutable data types 변경불가
: primitive types, frozen objects
Mutable data types 변경가능
: all objects by defult are mutable in JS
JS에서 array는 mutable data type이다


## variable types
### primitive type 더이상 작은 단위로 나눠질 수 없는 하나의 아이템
number, boolean, null, undefined, simbol

#### number
c언어와 java는 number에 얼마나 큰 데이터를 저장하는지 선언해야하지만 JS는 그럴필요 없음
JS에서는 integer와 decimal number 상관없이 타입은 number

```JS
const infinity = 1 / 0;
// positive한 value의 값을 0으로 나누면 무한대
const negativeinfinity = -1 / 0;
// negative한 value의 값을 0으로 나누면 무한대
const nAn = 'not a number' / 2;
// 숫자가 아닌 string을 숫자로 나누게 되면 nAn
* const bigInt = 1224456745889554785n;
// 숫자 끝에 n을 붙이면 bigInt로 인식(아직 지원안되는 브라우저 있음)
```

#### string
한가지의 글자든 여러개의 글자든 다 string 타입.
다른 string과 붙이는 것도 가능
##### template literals
```JS
`hi ${brendan}!`
```
이렇게 붙여서 쓸 수 있음

#### boolean
##### false
0, null, undefined,NaN, ' '
##### true
any other type

#### null
```JS
let nothing = 'null';
```
명확하게 empty 값을 지정 = null로 값이 할당됨

#### undefined
```JS
let x = 'undefined';
let x; // 위와 동일
```

선언은 되었지만 값이 아무것도 들어가지 않음

#### symbol
```JS
const symbol1 = Symbol('id');
const symbol2 = Symbol('id');
```

map이나 다른 자료구조에서 고유한 식별자가 필요하거나, 아니면 동시다발적으로 일어날 수 있는 코드에서 우선순위를 주고싶을 때, 정말 고유한 식별자가 필요할 때 사용
식별자를 string으로 두면 다른 코드에서 동일한 string을 만날때 같은 식별자로 간주함
반면 symbol은 동일한 string을 줘도 완전히 다른 식별자로 간주한다

```JS
const gsymbol1 = Symbol.for('id');
const gsymbol2 = Symbol.for('id');
```
만약 동일한 식별자를 주고싶다면 이렇게

```JS
console.log(`value: ${symbol1.decription}, type: ${tyopof(symbol2)}`)
```
출력하려면 이렇게 description으로 변환해야함





###(2)object type
real-life object, data structure
싱글 아이템들을 묶어서 한 단위, 한 박스로 관리할 수 있게 해줌
물건과 물체 형태를 대표할 수 있는 박스 형태를 뜻함
```JS
const ellie ={ name : 'ellie', age : 20 };
```

객체 ellie는 const로 선언되었기때문에 객체ellie가 가리키고있는 메모리의 포인터는 잠겨있어서 다른 object로 할당이 불가능
하지만 객체 ellie 안에는 name과 age라는 변수가 존재함. 그것들을 가리키고있는 포인터는 잠겨있지 않아서 다른 값으로 변경가능!
```JS
ellie.age = 21;
```

##### first-class function

function도 다른 데이터 타입처럼 변수에 할당이 가능
함수의 parameter(인자)로도 전달이 됨
함수에서 return 타입으로도 function을 리턴 가능

## Dynamic typing : dynamically typed language
C나 JAVA는 statically type이라 변수 선언 시에 어떤 타입인지 결정해서 선언했지만
JS는 선언할때 타입을 선언하지않고 런타임 시 할당된 값에 따라 타입이 변경될 수 있다
그래서 프로토타입 시에는 정말 유연하지만 규모있는 프로젝트에서는 좋지않다
```JS
let text = 'hello';
console.log(`value:${text}, type: ${typeof  text}`) // value:Hello, type:string

text = 1;
console.log(`value:${text}, type: ${typeof  text}`) // value:1, type:number

text = '7' + 5;
console.log(`value:${text}, type: ${typeof  text}`) // value:75, type:string

text = '8' / '2';
console.log(`value:${text}, type: ${typeof  text}`) // value:4, type:number
```
나누기 연산자가 있어서 string이 아닌 number로 변환되며 연산이 된다

=> 런타임 시 할당된 값에 따라 타입이 변하기때문에, 중간에 변수의 값이 바뀌면 오류가 발생한다 

# operator
1. string concatenation

```JS
console.log('my'+' cat');
console.log('1'+2);  //12
console.log(`string literals : 1 + 2 = ${1 + 2}`);
```

+ 기호를 이용해서 문자열을 합칠 수 있다

문자열+문자열 = 문자열 출력
문자열+숫자 = (숫자를 문자열 화)문자열 출력

` ` 백틱으로 string literals을 만들 수 있다.
중간에 변수가 삽입되면 계산해서 문자열로 돌려준다
줄바꿈이나 특수기호도 그대로 출력이 가능
(싱글쿼트 ' ' 의 사이에 '를 넣을 때는 \' 백슬러시를 넣어야만 한다)

2. Numeric operators
```JS
console.log(1 + 1); //add
console.log(1 - 1); //substract
console.log(1 / 1); //divide
console.log(1 * 1); //multiply
console.log(5 % 2); //reminder 나누고 나머지
console.log(2 ** 3); //exponentiation 2의 3승

```

3. Increment and decrement operators

```JS
let counter = 2;

const preIncrement = ++counter;
// 위 코드는 아래와 동일하다
//couter = counter + 1;
//preIncrement = counter;
// counter에 1을 더해서 값을 다시 counter에 할당한 다음에 preIncrement에 counter의 값을 할당한다

console.log(preIncrement, counter);
// 3,3 출력

const postIncrement = counter++;
// 위 코드는 아래와 동일하다
// postIncrement = counter;
counter = counter + 1;
// postIncrement에 counter의 값을 할당한 뒤에, counter에 1을 더해서 값을 다시 counter에 할당한다
console.log(postIncrement, counter);
// 3,4 출력

```



4. Assignment operators
```JS
let x = 3;
let y = 6;
x += y; // x = x + y;
x -= y;
x *= y;
x /= y;
```

5. Comparison operators
```JS
console.log(10 < 6);
console.log(10 <= 6);
console.log(10 > 6);
console.log(10 >= 6);
```

6. logical operators : ㅣㅣ(or) , &&(and) , !(not)

```JS

const value1 = false;
const value2 = 4 < 2;

console.log(`or: ${ value1 ㅣㅣvalue2ㅣㅣcheck() }`); //or : true

console.log(`and: ${ value1 && value2 && check() }`); //and : false

function check() {
for (let i = 0; i < 10; i++) {
console.log('print')
};
return true;
}

```

- or : finds the first truthy value

처음으로 true가 나오면 거기서 멈춘다.
만약 value1이 true라면 뒤가 뭐든 상관없음.
그러니까 check같은 expression을 제일 앞에 두면 안됨. 

=> 간단한 value들을 제일 앞에둬서 걔들이 false일때만 마지막에 마지못해 호출하는게 제일 좋다.

- and : finds the first falsy value
모두 true일 때만 true를 리턴한다.
or과 마찬가지로 앞의 value가 false라면 거기서 멈춘다. 뒤가 뭐든 상관없이 아예 실행조차 하지 않음

=> <strong>and또한 heavy한 operation일수록 제일 앞에서 체크하는 것이 좋다</strong>

<strong style="color:blue"> offen used to compress long if-statement </strong>
<strong style="color:blue"> 이러한 속성 때문에, null 체크문으로 사용된다 </strong>

```JS
nullableObject && nullableObject.something
```

* 맨 처음이 false라면 뒤를 실행조차 하지않는 속성을 이용한 간단한 null체크문.
* nullableObject가 null이 들어오면 false이기 때문에, 뒤가 실행되지 않는다!

- not : !

```JS
console.log(!value1);
```
값을 반대로 바꿔준다

7. Equality

```JS
const stringFive = '5';
const numberFive = 5;

// loose equality, with type conversion
console.log(stringFive == numberFive); // true
console.log(stringFive != numberFive); // false

// string equality, no type conversion
console.log(stringFive === numberFive); // false
console.log(stringFive !== numberFive); // true
```
- == / !== loose equality
: 타입을 변경해서 값을 비교한다

- === / !=== strick equality
: 타입을 엄수해서 값을 비교한다

* object equality by reference

```JS
const ellie1 = { name : 'ellie' };
const ellie2 = { name : 'ellie' };
const ellie3 = ellie1;

console.log(ellie1 == ellie2); // false
console.log(ellie1 === ellie2); // false
console.log(ellie1 === ellie2);// true
```
object는 메모리에 탑재될 때, reference 형태로 저장된다<br/>
<img src="/assets/images/JS_object.png" /><br/>

object ellie1과 ellie2는 들어있는 값은 같아보이지만, <br/>
실제로 1과 2에는 <strong>각각 다른 레퍼런스가 저장</strong>되어있음 <br/>
그 다른 레퍼런스는, 서로 다른 object를 가리키고 있다<br/>
ellie3는 ellie1과 동일한 레퍼런스를 가리키고 있음.<br/><br/>

그래서 ellie1과 ellie2는 타입을 동일하게 본대도 <strong>레퍼런스가 다르기 때문에</strong> 같지 않다!<br/>
타입을 엄수해서 비교해도 마찬가지로 <strong>레퍼런스가 다르기 때문에</strong> 같지 않음.<br/>
하지만 ellie3과 ellie1는 <strong>동일한 레퍼런스이기 때문에</strong> 같다!

* equality puzzler *

```JS
console.log(0 == false); // true
console.log(0 === false); // false 0은 boolean이 아니다
console.log('' == false); // true empty문자열은 false이다
console.log('' === false); // false empty 문자열은 boolean이 아니다
console.log(null == undefined); //true null과 undefined은 같다 (특이하게도)
console.log(null === undefined); //false null과 undefined는 다른 타입이다
```

8. Conditional operator: if
//if,else,lf,else

```JS
const name = 'ellie';
if(name === 'ellie') {
  console.log('Welcome, Ellie!');
}else if(name === 'coder') {
  console.log('You are amazing coder');
}else {
  console.log('unknown');
}
```
if statement가 true라면, 그 안에 있는 block을 실행하게 된다<br/>
그게 아니라면 else if, 그것도 아니라면 else로 넘어와서 block을 실행한다

9. Ternary operator: ?
//condition ? value1 : value2;

```JS
console.log(name === 'ellie' ? 'yes' : 'no');
```
길어지면 가독성이 떨어지기 때문에, 조건문이 간단할 때에만 사용하는 것이 좋다.

10. Switch statement
use for multiple if checks
use for enum-like value check
use for multiple type checks in TS

```JS
const browser = 'IE';

switch (browser) {
  case 'IE':
    console.log('go away!');
    break;
  // case 'Chrome':
  //   console.log('love you!');
  //   break;
  // case 'FireFox':
  //   console.log('love you!');
  //   break;
  case 'Chrome':
  case 'FireFox':
    console.log('love you!');
    break;
  default:
    console.log('love you!');
    break;
}
```
<strong>if문에서 else if를 반복한다면 switch를 쓰는 것을 고려하는 게 좋다!</strong>

만약 실행할 동작이 같은 경우엔 case를 연달아 쓰면 된다<br/>

TS에서 정해져있는 타입을 검사할 때에 switch를 쓰는 것이 가독성이 좋다<br/>

11. Loops
- while
while loop, while the condition is truthy,
body code is executed.

```JS
let i = 3;
while (i > 0) {
  console.log(`while: ${i}`);
  i--;
}
```

while의 statement가 false로 나오기 전까지는 무한대로 반복해서 계속 돈다.<br/>

- do while
do while loop, body code is excuted first,
then check the condition.

```JS
do {
  console.log(`do while: ${i}`);
  i--;
}while (i > 0);
```

먼저 블럭을 실행한 후에 조건을 검사한다.

=> 블럭을 먼저 실행하고 싶다면 do while, <br/>
조건에 맞을 때에만 블럭을 실행하고 싶다면 while을 써야한다!

- for
for loop, for(begin; condition; step)

```JS
for (i = 3; i > 0; i--) {
  console.log(`for: ${i}`);
}
```
for은 시작하는 문장, 컨디션, 어떤 스텝을 밟을 것인지를 명시한다<br/>
1) begin을 처음에 딱 한번만 실행하고 <br/>
2) 블럭을 실행하기 전에 컨디션이 맞는지 검사한 다음 <br/>
3) 블럭을 실행하고 <br/>
4) 스텝을 실행한다 <br/>

=> 컨디션이 맞을 동안 2,3,4를 반복한다 <br/>

이 for문처럼 기존에 존재하는 변수의 값을 할당하는 경우도 있고<br/>

```JS
for (let i = 3; i > 0; i = i - 2) {
  // inline variable declaration
  console.log(`inline variable for: ${i}`);
}
```

이렇게 for안에서, block안에 let으로 지역변수를 선언해서 작성할 수도 있다. <br/>

<strong>nested loops</strong>

* while과 for은 nested loops이 가능하다 <br/>

```JS
for (let i = 0; i < 10; i++) {
  for (let j = 0; i < 10; i++) {
    console.log(`i: ${i}, j: ${j}`);
  }
}
```

for문 속의 for문의 순서
1) i가 0일 때, j는 0~9까지 반복되고<br/>
2) i가 1일 때, j는 0~9까지 반복되고<br/>
.....<br/>
ex)구구단<br/>


* break, continue<br/>
loop 안에서는 break와 continue를 이용해 루프를 끝낼 수 있다!<br/>

- break
: 루프를 완전히 끝냄
- continue
: 지금 것만 스킵하고, 다음 스텝으로 넘어감<br/>

Q1. iterate from 0 to 10 and print only even numbers (use continue)<br/>

```JS

for(let i = 0; i < 11; i++) {
  if(i % 2 !== 0) {
    continue;
    // 2로 나눴을 때 0이 아니면 스킵하고 다음 스텝으로
  }
    console.log(`even number is : ${i}`)
}
// 실무적인 답 :
// for(let i = 0; i < 11; i++) {
//   if(i % 2 == 0 && i > 0) {
//       console.log(`even number is : ${i}`)
//   }
// }

```
<br/>

Q2. iterate from 0 to 10 and print numbers until reaching 8 (use break)<br/>

```JS

for(let i = 0; i < 11; i++) {
  if(i == 8){
    break;
  }
  console.log(`number is : ${i}`);
}

```
<br/><br/><br/><br/><br/><br/>


# Arrow function

sub-program<br/>

모든 프로그램이 각각의 기능이 있는건 모두 다른 function을 사용하기 때문.<br/>
프로그램 안에서 작은 기능들을 수행하는 것이 function이다<br/>

Input으로 parameter를 받아서 처리하고,<br/>
Output으로 return을 하는 것이 function<br/>

그래서, 언어 자체에 존재하는 function을 쓰거나<br/>
API(application programming Interface)를 쓸 때, function의 이름을 보고 그 기능을 예상할 수 있음<br/>
전달해야하는 파라미터 값이 뭔지, 어떤 값이 return되기를 기대할 수 있는지 이런 Interface를 보면서 예상할 수 있다<br/>

그래서 Input과 output이 중요하고, function의 이름이 중요한 것!

## function
프로그램을 구성하는 기본적인 빌딩블럭<br/>
sub program이라고도 불리며, 여러번 재사용이 가능하다<br/>
한가지의 task나, 어떤 값을 계산하기 위해 쓰여짐<br/>

 ## 1. function declaration
함수를 정의하는 방법!<br/>

```JS

function name (param1,param2) { body... return; }

```
function 키워드 입력<br/>
name 이름 지정<br/>
parameters 나열<br/>
body 함수의 기본적 비즈니스 로직 작성<br/>
return<br/><br/><br/>

- 하나의 함수는 한가지의 일만.
- 변수 네이밍이 명사이듯이 함수 네이밍은 doSomething형태, command 형태, verb 형태로
* 만약 이름짓는게 너무 어렵다면? 너무 많은 일을 하고있지는 않는지 생각! *
e.g. createCardAndPoint -> createCard, createPoint로 세분화<br/><br/>

- function은 JS에서 object로 간주된다
그래서 변수에 할당할 수 있고, parameter로 전달이 되고, 함수를 return할 수 있는 것.<br/>

Type Script )

function log(message:string) {
    console.log(message);
}

TS에서는 parameter나, return의 타입을 지정하지 않으면 오류가 뜬다.
- parameter의 타입은 (message:string) 이렇게
-return의 타입은 (message:string):number이렇게

타입을 명시해줘야함

* 이 TS는,

- 규모있는 프로젝트
- 여러 개발자와 협업을 할 때
- 우리가 작성한 것을 API형태로 라이브러리로 제공해야할 때

위와 같은 상황에서 개발을 원활하게 만들어준다!

: 함수의 인터페이스만 봐도, 이 함수가 뭘 하는 함수이고 어떤 파라미터를 전달해야하고 어떤 데이터 타입인지, 어떤 값이 리턴되는지를 명확하게 알 수 있기 때문에.


 ## 2. Parameters

function에 전달되는 이 parameters는
- Premitive parameters: passed by value
: 메모리에 그대로 저장되기 때문에, value가 전달된다

- object parameters: passed by reference
: reference가 저장되기 때문에 reference가 전달된다

```JS

 function changeName(obj) {
   obj.name = 'coder';
 }
 //전달된 객체 안의 name을 변경하는 함수
 const ellie = { name: 'ellie'};
 changeName(ellie);
 console.log(ellie); //ellie

 ```

object는 reference로 저장됨. 아래는 예시
<img src="/assets/images/JS_object.png" /><br/>

object는 reference로 전달되기 때문에,<br/>
함수 안에서 객체의 값을 변경하게 되면 변경된 사항이 그대로 메모리에 적용된다


## 3. Default parameters (added in ES6)
default 값을 미리 지정할 수 있는 default parameters

* 기존의 방식

```JS
function showMessage(message, from) {
  if(from == undefined) {
    from = 'unknown';
  }
  console.log(`${message} by ${from}`);
}
showMessage('Hi!');
```
기존에는 이렇게, undefined일 경우를 대비해서 조건문을 작성해야했지만

* ES6의 방식

```JS
function showMessage(message, from = 'unknown') {
  console.log(`${message} by ${from}`);
}
showMessage('Hi!');
```

사용자가 parameter값을 전달하지 않을때, 값이 이렇게 기본값으로 대체되어서 사용된다

4. Rest parameters (added in ES6)

```JS
function printAll(...args) {
  for(let i = 0; i < args.length; i++) {
    console.log(arg[i]);
  }
}
printAll('dream','coding','ellie'); //인자로 세개의 값을 전달
```
... 이렇게 전달하면 배열 형태로 전달이 된다!<br/>
'dream','coding','ellie' 이렇게 전달받은 값은 세개의 값이 담긴 배열이 된다<br/>

```JS
function printAll(...args) {
    for(const arg of args) {
    console.log(arg);
  }
}
printAll('dream','coding','ellie'); //인자로 세개의 값을 전달
```
for문보다 간단한 for of문으로 작성할 수도 있음 <br/>
arg에 있는 모든 값들이, 차례대로 하나씩 arg로 지정이 되면서 출력하게 된다

```JS
function printAll(...args) {
    args.forEach((arg) => console.log(arg));
  }
}
printAll('dream','coding','ellie'); //인자로 세개의 값을 전달
```


## 5. Local scope

참조) closer, LexicalEnvironment <br/>

* 밖에서는 안이 보이지 않고, 안에서만 밖을 볼 수 있다

이것이 scope의 개념

```JS
let globalMessage = 'global'; // global variable 전역변수
function printMessage() {
  let message = 'hello';
  console.log(message); // lacal variable 지역변수
  console.log(globalMessage);

  function printAnother() {
    let childMessage = 'hello';
  }
  // console.log(childMessage) //error
}
printMessage();
```

자식은 부모에게서 정의된 메시지를 확인할 수 있다지만 <br/>
자식 안에 정의된 childMessage를 부모에서 볼 수 없음

* 중첩된 함수에서 자식의 함수가, 부모 함수에 정의된 변수에 접근이 가능한 것들이 바로 closer.



## 6. Return a value

```JS
function sum(a, b) {
  return a + b;
  }
  const result = sum(1,2); //3
  console.log(`sum: ${sum(1,2)}`);
```

parameters로 값을 전달 받아서, 계산된 값을 return할 수 있다

```JS
let globalMessage = 'global';
function printMessage() {
  let message = 'hello';
  console.log(message);
  console.log(globalMessage);

  function printAnother() {
    let childMessage = 'hello';
  }
   return undefined;
}
printMessage();
```

아까 봤던, 이렇게 return이 없는 함수들은 return undefined가 된 것과 같다<br/>
모든 함수는 return undefined이거나, 값을 Return할 수 있다


## 7. Early return, early exit

* 나쁜 예!

```JS
Function upgraderUser(user) {
  if(user.point > 10) {
    //long upgrade logic
  }
}
```
해당 조건일 때에만 무언가 작동하는 로직이 있다. block안에서 로직을 많이 작성하면 가독성이 떨어진다.

* 좋은 예!

```JS
Function upgraderUser(user) {
  if(user.point <= 10) {
    return;
  }
    //long upgrade logic
}
```
if else를 번갈아서 쓰는 구조보다는, 조건이 맞지 않을 때 이렇게 빨리 return 시켜버리고!<br/> 
조건이 맞을 때만 그 다음으로 와서 필요한 로직들을 쭉 실행하는 구조가 좋다.

- 조건이 맞지 않는 경우
- 값이 undefined인 경우
- 값이 -1인 경우






# First-class function
- function are threated like any other variable
함수는 다른 변수처럼 사용된다
- can be assigned a value to variable
다른 변수에 할당이 된다
- can be passed as an argument to other functions.
함수의 parameter로 전달이 되며
- can be returned by another function
return값으로도 return이 된다

1. Function expression

function declaration / function expression

- a function declaration can be called earlier than it is defined. (hoisted)

: function declaration은 hoisting이 된다. 정의하기도 전에 호출이 가능함!<br/>
(JS엔진이 선언된 것을 제일 위로 올려주기 때문)

- a function expression is created when the execution reaches it.

function expression은 할당된 다음부터 호출이 가능함.


```JS
// const print = function print () { // named function 
const print = function () { // anonymous function
  console.log('print');
};
print(); //호출, 'print' 출력
const printAgain = print; //'print' 출력
printAgain();
const sumAgain = sum; //위에서 만든 sum함수를 넣어도 가능
console.log(sumAgain(1,3));

```

2. Callback function using function expression


```JS

function randomQuiz(answer, printYes, printNo) {
  if(answer === 'love you') {
    printYes();
  } else {
    printNo();
  }
}

const printYes = function () {
  console.log('yes!')
}


// named function
// better debugging in debugger's stack traces
// recursions

const printNo = function print () {
  console.log('no!')
}

randomQuiz('wrong', printYes, printNo); // 정답이 아니라면 no, 맞으면 yes를 출력해라
randomQuiz('love you', printYes, printNo); // 정답이 아니라면 no, 맞으면 yes를 출력해라

```

이렇게 함수를 전달해서<br/>
<strong style="backgroud-color:blue, color:white" >상황이 맞으면, 전달된 함수를 불러"</strong><br/>
라고 하는 것을 Callback function이라고 한다!<br/>

두가지의 callback functions가 parameter로 전달 <br/>

printYes에는 anonymous function을, printNo에는 named function을, 쓴 이유? <br/>

- debugging의 stack trace에 함수 이름이 나오게 하기 위해
- 함수 안에서 자신 스스로 또다른 함수를 호출할 때 (Recursions)



3. Arrow function
: always anonymous

```JS

const simplePrint = function () {
  console.log('simplePrint!');
}

const simplePrint = () => console.log('simplePrint!');
const add = (a,b) => a + b;

const simpleMultiply = (a,b) => {
  // do something more
  return a * b;
}

```

4. IIFE : Immediately Invoked Function Expression

: 선언과 동시에 호출

```JS
function hello() {
  console.log('IFFE')
hello();
```
이렇게 함수를 따로 호출하지 않고

```JS
(function hello() {
  console.log('IFFE');
})();
```
괄호로 묶어서 함수를 호출해주면, 선언과 동시에 호출이 가능하다

