---
title: "React란? #1 리액트 프로젝트 시작하기 ⭐️"
permalink: /cs/ReactProgramming
tags:
  - [CS]

navigation: true
toc: true
toc_sticky: true

date: 2021-12-02
last_modified_at: 2021-12-02
---

![]()

# 리액트란 무엇인가?


UI 기능만 제공

앵귤러와는 달리 개발환경 직접 구축해야함!


- 자동으로 업데이트 되는 UI
- UI = render(state)
- render함수는 `순수함수`로 작성(입력값이 같으면 출력값이 똑같아야 하는 것)
  - 랜덤함수사용 x
  - 외부상태변경 x
- state는 `불변변수`로 관리! (새로운 객체를 만들어서 값을 할당하는 것)
- 가상돔(virtual DOM) : 이전 UI상태를 메모리에 유지해서 변경된 부분만 업데이트하는 것!

=> 순수함수와 불변변수를 적극사용하면 버그발생 낮아지고 복잡도가 낮아짐
그리고 랜더링 속도도 빨라짐


(객체지향 프로그래밍과 반대되는 개념이 함수형 프로그래밍)

# 리액트 개발환경 직접 구축하기

React.useState는 이 파일이 실행될 때 전역변수로 실행이 된다!

createElement
- UI를 표현하는 가장 작은 단위가 리액트 요소이다
- 첫번째 인자로 선택한 태그, 두번째 인자로 함수 메소드 및 스타일 등


# 바벨 사용해보기

- 자바스트립트 코드를 변환해주는 컴파일러
- 최신 자스 문법을 지원하지 않는 환경에서도 
createElement로
- react 에서는 JSX 문법을 사용할 때 변환하기위해 사용

npm init -y (패키지 제이슨 파일이 설치됨)
npm install @Babel/core @babel/

npx babel

- 프리셋과 플러그인
  : 여러개의 플러그인을 특정 목적으로 모아둔 것이 프리셋인 것.



# 웹팩 사용해보기

- 다양한 기능 제공

  - 파일 내용을 기반으로 파일 이름에 해시값 추가 => 효율적 프라우저 캐싱
  (Vㅏ일 이름 자체가 해시의 키가 된다면 서버에게 ㅇ물어볼 필요가 없은 ㅣ효율적

  - 사용되지 않은 코드 제거
  - Java Script 압축
  - JS, CSS, JSON 텍스트 파일 등 일반 모듈처럼 불러오기
  - 환경 변수 주입

- 웹팩을 사용하는 가장 큰 이유 => 모듈 시스템을 사용하기 위해서!

export 

하나하나로 다 묶어두고, 빼다 쓰는 것을 모듈시스템이라고 한다.
export default 를 사용하지 않으면 중괄호로 담아서 import 해야한다!
as로 이름을 변경할 수도 있음.

웹팩을 사용하면 변수이름 충돌 등은 빌드단계에서 해결 가능
외브라이브러릴는 npm으로 관리 가능

- 요즘 브라우저는 ESM을 지원한다. 하지만
  - 오래된 브라우저
  - 많은 오픈소스가 commonJS로 작성됨








==========다른파일









# create-react-app(CRA)

리액트 개발환경을 직접 구축하려면 많은 지식과 노력이 필요함.

빌드 시스템 구축을 위해서 웹팩과 바벨 등을 써야하고,
제스트를 이용해서 테스트 환경 구축해야하고,
오래된 브라우저 지원을 위해 polyfill 도 추가를 해야하고,
HMR 코드 수정 시 화면에 바로 적용되는 기능과 css 후처리 등도 처리해야함

=> create-react-app이 자동으로 구축해서 제공해준다 !



서버사이드 랜더링의 지원여부

cra는 지원하지 않음!
깔끔한 방법이 아ㅓㅂㅅ다

필수인 프로젝트면 Next/js를 선택해야함.

백오피스처럼 서버사이드 랜더링이 필요없을 때 쓰는 것.

cra는 빌드시스템 변경이 불가능함.



npm start 는 개발모드에서만 써야함. 성능 최적화가 안되어있어서

배포할때는 반드시 build명령어를 써야한다

serviceWorker는 serviceWorker.unresister 되어있기 때문에 아직 동작하지 않음


strictMode는 리액트에서 잘못 사용하는 것을 잡아내기 위해 쓴다.

import logo from '~~.svg'이렇게
이미지 해시 값으로 사용하는게 좋다. 브라우저 캐싱을 효율적으로 활용이 가능!
이미지 뿐만 아니라 데이터도 마찬가지.
데이터가 특정 순간에만 필요하다고 할 때에도, 해시값으로 받아오는게 좋다.
- 1. 그냥 데이터를 받아오게 해두면, 버튼 클릭하기도 전에 데이터가 있는 상태로 번들이 구성이된다
- 2. import로 또 쓰면 파일이 받아와진다

```JS

import('./data.json')// 1번의 경우

function onClick() {
  import('./data.json').then({default: data}) => {
    console.log({ data })
  } // onClick 함수안에 담은 2번의 경우
}

```






npm start로 사용하게 되면 기본적으로http가 실행된다.

https로 실행하고싶다면 `HTTPS=true npm start`
윈도우는 https로 실행하고싶다면 `set HTTPS=true && npm start`

빌드하게 되면 정적파일이 생성이 됨.
build폴더 안에 있는 정적파일로 서비스만 하면 된는 것.
그러니까 서버사이드 랜더링으로 동작을 할 수 없는 것!

> react developer tools 크롬 익스텐션


bulid 명령어
빌드 시 큰이미지는 media폴더 안에 내장되는데,
HTTP요청 횟수를 줄이기 위해, 작은 image를 JS파일 내부에 포함한다. (2.0부터는 성능이 좋아져서 그럴 필요는 없긴함)
좀 더 빠르게 이미지를 보여줄 수 있는 장점이 있다.


text 명령어 
(test.js를 붙이면 test 파일이 된다.)

eject 명령어

react-scripts를 사용하지 않고 모든 설정파일을 `추출`하는 명령어
cra를 기반으로 직접 개발환경을 구축하고 싶을 때

추출하지 않으면 cra rㅣ능 추가됫을 때 단순히 버전만 올리는것만 하면 되는데,
추출을 하면 설정파일을 수정을 해버려야하니까 꼭 필요하지 ㅇ낳다면 관리측면에서 추출하지 않는 것이 좋다. 

polyfill

IE에서 지원안되는 것을 지원하고 싶을 ㅅ때 사용.

CRA는 기본적으로 core.js가 내장되어있어서 import 만하면 됨.
보통 core.js 를 사용한다.


`환경변수`란?
환경변수는 개발, 테스트 또는 배포 환경별로 다른 값을 적용할 때 유용하다.
전달된 환경 변수는 코드에서

```JS
process.env.{변수이름}
```
이렇게 사용할 수 있따

CRA는 기본적으로 NODE_ENV라는 값을 가지고 있음.
npm start 로 실행하면 .env.development
npm test는 .env.test
npm build는 .env.production






# CSS 작성방법 결정하기

- 일반적인 css파일 작성
 : 이름 충돌 문제

- css 모듈
 : module.css 형식으로 작성.
 객체 형식이기 때문에 객체로 들어옴
 해시값이 붙어서 들어가기때문에, 각 클래스명은 고유값을 가진다. 이름충돌문제 해결!
 classnames라는 걸 설치하면 좀 더 깔끔하게 작성할 수 있다
 cn(Style.button, Style.small)

- Sass
 : node sass를 설치해야함. modulecss와 함께 사용할 수 있음. 변수 사용가능

- css-in-js
 : 재사용가능한 구조로 사용할 수 있음! JS안에있는 css
  - styled-components








SPA가 가능하기 위한 조건

- 자스에서 브라우저로 페이지 전환 요청을 보낼 수 있다
  - Qㅡ라우저는 서버로 요청을보내지 않아야한다
- 브라우저의 뒤로가기같은 사용자의 페이지 전환 ㄴ요청을 자스에서 처리할 수 있다
  - Qㅡ라우저는 서버로 요청을보내지 않아야한다

위조건은 만족하는 브라우저 API

- pushState, replaceState 함수
- popstate 이벤트

JS가 페이지전환을 하고싶을 때,
페이지전환 이벤트를 브라우저에게 알려주는 방법은 pushState, replaceState 함수를 호출하는 것.
반대로 브라우저에서 사용자가 브라우저 UI를 통해서 페이지전환을 하고싶을 때,
페이지전환 이벤트를 JS에게 알려주는 방법은 popstate 이벤트를 통해서 알려준다

onPopState 이벤트를 등록하기위해서 useEffect를 사용했다

SPA는 서버로 요청이 가지 않음!!!
아까 눌렀던 페이지를 기억해서 뒤로가기를 누르면


현재 페이지 이름을 저장하기 위해서 pageName


react-router-dom

페이지별로 코드분할을 위한 react-router-dom

`npm install react-router-dom`

path정보에 따라 어떤 컴포넌트를 랜더할지 결정한다
(정확성)exact를 넣은 것도 기억.
match 안에는 url이 있다. 속성값이 의미하는 것은 
path 가 /rooms인데, 
/rooms/1, /rooms/2, /rooms/3
/rooms는 모두 rooms 컴포넌트가 랜더링이 될텐데, 마지막으로 매치됐던 부분=동일한 프리픽스 url이 /rooms match.url로 이렇게 들어간다.
exact 속성을 넣고 match



## 리액트를 사용한 코드의 특징


button이 가지고 있는 (data-id)
dataset
내가 선택한 엘리먼트가 맞는지 확인하고, 맞으면 변경할때 쓰고
삭제하기 위해서 쓰는경우도 있다

이벤트핸들러에서 데이터변경하는 작업만 한다.
html은 ui코드도 함께 있다.

비즈니스 로직과 분리가 되어있다.

화면을 어떻게 표현하는지(명령형 프로그래밍) html
화면에 무엇을 그려야하는지(선언형 프로그래밍) react

html, 명령형 프로그래밍은
  실행되고 여러이벤트가 발생하면서, ui가 어떤 모습일지 한눈에 보이지않는다.
  돔 api를 이용하면 돔환경이 아니면 사용하기 힘들다.
react, 선언형 프로그래밍은
  무엇을 그릴지만 나타내기 때문에, react는 모바일네이티브의 ui도  표현이 가능

=> react는 추상화단계가 높다. 추상화단계가 높을수록 비즈니스 로직에 집중할 수 있다.





## 컴포넌트의 속성값과 상탯값

react에서는 UI 데이터를 속성값이나 상태값으로 관리를 한다

react가 변경됐다는 사실을 알기위해서는 상태값으로 관리해야한다.

React.memo 속성값이 변경될 때만 컴포넌트가 랜더링된다.

속성값은 불변이지만 상태는 불변아님. 하지만 상태도 불변변수로 만드는게좋다.

read only 에러! 직접 수정하지 못함.

값을 변경하려면 상태값 변경함수를 사용해야한다.

상태값의 변경은 이전값과의 단순비교로 판단한다.
변경함수로만 해줘야 이전값과 비교해서 변경을 화깅ㄴ하고 랜더를 하는떼.
setCount(count)이렇게 직접적으로 하면 이전값이랑 비교가 안됨.

왜 state를 불변으로 해야하는가?
이전 상태값과 비교를 해서 랜더를 해야하기 때문에.



## 컴포넌트 함수의 반환값

문자열, 숫자, 배열, 컴포넌트, 요소, 프레그먼트,null, boolean.... 모든 것을 반환할 수 있다.

boolean은 조건부 랜더링시 유용

배열로 반환할때는 key요소를 넣어줘야한다.

react가 이 값을 이용해 virtual dom에서의 연산을 편하게 할 수 있다.

<React.Fragment></React.Fragment>>프레그먼트(요소의 순서가 키 역할을 해서 key 필요없음)

React Potal은 root 엘러먼트 말고 다른 멀리 떨어진 엘리먼트에 랜더링하고 싶을 때 사용
react-dom에 있는  createPotal 함수 사용

기본적으로  root에다 출력을 하겠다 박아놓기때문에.
그래야 이 react가 이걸 이해한다.
사용된 위치랑 상관없이, 랜더위치를 지정하고 싶을 때 많이 사용한다.
(보통 모달을 위해서 많이 사용됨)

## 리액트 요소와 가상돔

리액트 요소란, 리액트가 UI를 표현하는 방법
빠른 랜더를 위해 돔 변경을 최소화하는것이 좋다.
`변경된 부분만 돔에 반영` 되는 방식.

리액트 요소 또한 불변 요소. 변경 불가

그런데 상태값을 돔 요소의 key에 넣어버리면?
`돔 요소의 key를 변경`하면 react는 그걸 `다른 요소라고 판단`해서 이전것을 삭제하고 새로 만들어서 붙인다.

`컴포넌트의 key값을 변경`하면 해당 컴포넌트는 삭제(언마운트)됐다가 추가(마운트) 됨

트리는 시간에 따라 변하는 화면의 한 순간을 나타낸다.

### 리액트 요소가 돔 요소로 만들어지는 과정

랜더단계(가상 돔, 파악 하는 단계) 
커밋단계(실제 돔, 파악된 변경사항을 실제돔에 반영하는 단계)

랜더링할때마다 가상돔을 만들고, 실제돔과 비교한다. **실제 돔의 변경사항을 `최소화`하기 위한 과정**

리액스 요소 트리 요소가 실제 돔으로 만들어지기 위해서는, 모든 리액트 요소의 `타입 속성값이 문자열`이어야한다.
`타입 속성값이 문자열`인 트리요소가 **바로 가상 돔**

UI변경된 부분을 빨리찾기위한 개념.

변경되지 않은 부분은 재사용됨.

1. 랜더함수가 호출되면서 최초의 랜더단계가 실행됨
2. 이렇게 만들어진 가상 돔이 실제 돔으로 만들어짐
3. 사용자의 버튼클릭으로 상태값이 변경
4. 두번째 랜더단계가 실행
5. 새로운 가상돔이 생성(이전에 가상돔과 비교해서 실제 변경된 부분만 재랜더됨)


### 훅

- 컴포넌트 기능 추가할 때 사용하는 함수

  - 상탯값 추가, 자식요소 접근
  - 그전에는 클래스형 컴포넌트
  - 클래스보다 장점이 많고 리액트 팀에서도 훅에서 집중

- useSTate상탯값 처리
- useEffect 부수효과 처리(외부의 상태를 변경하는 것)
  - 서버 API 호출, 이벤트 핸들러 등록 등

useState
배열을 반환
효육적으로 처리하기위해 여러개의 상태값변경 요청을 비동기,배치로 처리하기 때문에, 한번만 된다.
동기로 처리하면 하나 호출될때마다 다시 그리기때문에 성능이슈

setCount(count + 1)
setCount(count + 1) // 한번만 실행

setCount(v => v + 1)
setCount(v => v + 1) // 처리되기 직전의 상탯값을 매개변수로 받기 때문에 원하는대로 처리 가능.

onClick 이벤트핸들러는, 리액트에서 관리하는 리액트요소에 입력되어있기 때문에,
리액트에서 관리하지않는 외부에서 호출하는 경우에는 배치처리한다.
onClick(내부)={onClick(외부)}

변경함수는 호출한 순서대로 처리된다.(배치로 처리될때는 별 의미가 없음)

객체로 변경할때는 전체를 입력해줘야한다.

여러상태값을 변경할 때에는 useState보다는 useReducer가 낫다.

모든 부수효과는 useEffect로 관리하는 것이 좋다.
모든 컴포넌트 랜더링 중에 부수효과를 발생시키면 복잡도 크게 증가

이닛텍스트 작서이 힘들어지는 등 순수함수 사용하는 이유 사라짐

컴포넌트 내부에서 직접 실행하는 부수효과가 있으면 한번 랜더링될 때 컴포넌트가 여러번실행될 수 있다.
`부수효과 함수`

의존성 배열. 값이 변경될 때만 부수효과함수가 실행됨

부수효과함수는 마운트 된 이후에 한번만 호출됨.

부수효과함수의 의존성 배열에는 사용한 변수를 넣음.
지역변수가 있다면 반드시 지역변수도 입력해야한다.

외부함수는 의존성배열에 입력할 필요 없지만, 지역함수를 부수효과 내부에서 사용했다면 지역함수는 입력해야함!

useCallback(메모이제이션이 가능)

부수효과함수가 반환하는 값

언마운트 되기 전에 한번은 호출됨.

사라질때 적어도 한번은 

의존성배열을 빈배열로하면!
- 생성시에만 부수효과함수 호출
- 사라질때만 반환한(return) 함수 호출

빈배열을 추가하지않으면?
- 생성시에만 부수효과함수 호출
- 사라질때만 반환한(return) 함수 호출

없애버리면 상태 변경시마다 이 안에 있는 부수함수든, 반환한 함수든.

## 커스텀 훅 만들기


랜더만 제외하고 함수를 뚝 떼서, 함수형으로 재사용성이 좋게 한다.

서버사이드 랜더링시에 좋은, 마운트 유무

마운트됐다는건 첫번째 랜더링이 끝났다는 것.
매번호출될 필요는 없으니까 빈배열을 넣는다.

useBlockifNotUser()
로그인된 사용자만 접근할 수 있는 페이지다ㅏ!
저장하지않고 페이지 벗어나려고 하면 저장되지않은 정보가 있다는 알림을 띄우기도 좋음.
useBlockUnsavesChange(desc) 이런식으로 상태값을 받아서

로그인유저일때만 실행하고 싶을 때
useEffectIfLoginUser(vallback, deps)


로컬스토리지
토큰 등을 받아서 사용할 때,
useLocalStorage(key, initialValue) => [value, setValue]

key로 토큰 등을 받아서 스토리지로 전달시킬 수 있다.



규칙!
1. 하나의 컴포넌트에서 훅 호출 순서는 늘 같아야한다
  - 1. if문, for문 등의 안에서 hook을 사용하면 안됨
      **함수 안에서 사용해도 안된다. 이게 늘 호출된다는 보장이 없으니ㄷ까!**  
  ```JS
  if(!user) {
    return null;
  }
  const [value, setValue] = useState(1) //안돼!
  ```

  이것도 어쩔땐 호출되고 어쩔땐 안되니까 안됨!

  ```JS
  if(!user) {
    return null;
  }
  return {... }
  ```
  이렇게 return을 반드시 붙여서 사용해주기.

2. 훅은 함수형 커뫂넌트 또는 커스텀 훅 안에서만 호출되어야한다.

(그래야 리액트가 훅삳ㅇ태를 제대로 기억할 수 있다.)

hook은 함수형 컴포넌트를 위한 기능!


react는 이렇게, 각 훅이 사용된 위치정보를 기반으로 훅 데이터를 관리한다.


3대 훅! 
- useState
- useEffect
- useContext




